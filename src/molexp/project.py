from hamilton import driver
from hamilton.experimental.h_cache import CachingGraphAdapter
from hamilton.plugins import h_experiments
from hamilton.function_modifiers import value, parameterize, resolve, ResolveAt
from hamilton.execution.executors import DefaultExecutionManager
from hamilton.execution import executors

import os
from pathlib import Path

from .param import Param, ParamList
from hamilton import settings


def execute_exp(
    name: str, root: str, param: Param, materilizers: list, config: dict, modules: tuple
) -> None:
    tracker_hook = h_experiments.ExperimentTracker(
        experiment_name=name,
        base_directory=root,
    )
    os.chdir(tracker_hook.run_directory)
    execution_manager = DefaultExecutionManager(
        executors.SynchronousLocalTaskExecutor(),
        executors.MultiThreadingExecutor(20),
    )
    dr = (
        driver.Builder()
        .with_modules(*modules)
        .enable_dynamic_execution(allow_experimental_mode=True)
        .with_execution_manager(execution_manager)
        .with_config(config)
        .with_adapters(tracker_hook)
        .build()
    )
    dr.materialize(*materilizers, inputs=dict(param))


class Project:

    def __init__(self, name: str, work_dir: str | Path = Path.cwd()):

        self.name = name
        self.experiments = {}
        self._root = Path(work_dir).absolute() / name
        self.pre_exec_dir = Path(self.root) / ".pre_exec"
        if not self.pre_exec_dir.exists():
            self.pre_exec_dir.mkdir(parents=True, exist_ok=True)

    @property
    def root(self):
        return self._root

    def pre_execute(self, materilizers:list, *modules: list):

        execution_manager = DefaultExecutionManager(
            executors.SynchronousLocalTaskExecutor(),
            executors.MultiThreadingExecutor(20),
        )
        os.chdir(self.pre_exec_dir)
        cache = Path(".cache")
        if not cache.exists():
            cache.mkdir(parents=True, exist_ok=True)
        dr = (
            driver.Builder()
            .with_modules(*modules)
            .enable_dynamic_execution(allow_experimental_mode=True)
            .with_execution_manager(execution_manager)
            .with_adapters(CachingGraphAdapter(str(cache)))
            .build()
        )
        dr.materialize(
            *materilizers
        )
        os.chdir(self.root)

    def execute(self, param_list: ParamList, materilizers: list | None = None, *modules: list):

        execution_manager = DefaultExecutionManager(
            executors.SynchronousLocalTaskExecutor(),
            executors.MultiThreadingExecutor(20),
        )

        from molexp import project

        parameters = {param.name: {k: value(v) for k, v in param.items()} for param in param_list}
        exp_names = {param.name: {"name": value(param.name)} for param in param_list}
        parameters.update(exp_names)
        project.execute_exp = resolve(
            when=ResolveAt.CONFIG_AVAILABLE, decorate_with=lambda: parameterize(**parameters)
        )(project.execute_exp)

        dr = (
            driver.Builder()
            .with_modules(project)
            .enable_dynamic_execution(allow_experimental_mode=True)
            .with_execution_manager(execution_manager)
            .with_config({settings.ENABLE_POWER_USER_MODE: True})
            .build()
        )

        dr.execute(
            final_vars=list(exp_names.keys()),
            inputs={
                "root": str(self.root),
                "materilizers": materilizers,
                "config": {},
                "modules": modules,
                "param": param_list[0],
                "name": param_list[0].name,
            },
        )

    def list(self):
        """list all experiment"""
        return self.experiments

    def group(self, key: str):
        """group experiments by key, since we need to average the results
        for example:
            input: {'a': 1, 'b': 2, 'id': [1, 2, 3]} # means 3 experiments generated by a=1, b=2
            output: len(project.group('id')) == 3
            ave_results = np.mean([exp.get_something for exp in project.group('id')])
        """
        pass


class Experiment:

    pass
