from hamilton import driver
from hamilton.io.materialization import to
from hamilton.experimental.h_cache import CachingGraphAdapter
from hamilton.plugins import h_experiments, matplotlib_extensions, pandas_extensions  # noqa: F401
from hamilton.function_modifiers import tag, value, parameterize

from molexp.cmdline import CMDLineExecutionManager
from hamilton.execution import executors

from .param import Param

def _execute(*args, **kwargs):
    tracker_hook = h_experiments.ExperimentTracker(
        experiment_name="exp",
        base_directory="./experiments",
    )

    execution_manager = CMDLineExecutionManager(
        executors.SynchronousLocalTaskExecutor(),
        executors.SynchronousLocalTaskExecutor(),
    )

    materializers = [
        to.pickle(
            id="after_build",
            dependencies=["submit"],
            path="/proj/snic2021-5-546/users/x_jicli/exp/.cache/to_lammps.pickle",
        )
    ]

    # jichen: Can we use `materialize` to make seperated experiment folder,
    # or mkdir manually? 
    Path(inputs["work_dir"]).mkdir(exist_ok=True)

    meta, _ = dr.materialize(*materializers, inputs=inputs)
    return meta

class Project:

    def __init__(self, name: str):
        self.dr = (
        driver.Builder()
        .with_modules(build, eq, tg)
        # .with_config(config)
        .with_adapters(tracker_hook, CachingGraphAdapter(".cache"))
        .enable_dynamic_execution(allow_experimental_mode=True)
        .with_execution_manager(execution_manager)
        .build()
    )
        self.experiments = {}
        

    def execute(self, param_list: list[Param], ):
        """
        execute experiments parallelly
        """
        hamiltom_params = {}

        for param in param_list:
            exp_name = '_'.join(f"{k}x{v}" for k, v in param.items())
            hamiltom_params[exp_name] = param

        # TODO: dynamic generate parametrize function
        # 1. change signature according params
        # signature = {k: type(v) for k, v in param.items()}
        # 2. parametrize function
        # parameterize_exec_fc = parameterize(**hamiltom_params)(exec_fc)
        # 3. save function in another file (new_module)
        # inspect.getsource(parameterize_exec_fc) -> save in new_module.py
        # 4. import new_module
        # dr.with_modules(new_module)

        execution_manager = CMDLineExecutionManager(
            executors.SynchronousLocalTaskExecutor(),
            executors.MultiThreadingExecutor(20),
        )

        dr = (
            driver.Builder()
            .with_modules(new_module)
            # .with_config(config)
            .enable_dynamic_execution(allow_experimental_mode=True)
            .with_execution_manager(execution_manager)
            .build()
        )
        # dr.display_all_functions("run_batch1.png")
        dr.execute([dr.list_available_variables()])

    def list(self):
        """list all experiment"""
        pass

    def group(self, key: str):
        """group experiments by key, since we need to average the results
        for example:
            input: {'a': 1, 'b': 2, 'id': [1, 2, 3]} # means 3 experiments generated by a=1, b=2
            output: len(project.group('id')) == 3
            ave_results = np.mean([exp.get_something for exp in project.group('id')])
        """
        pass

class Experiment:

    pass